Основы командной строки


Установка WSL
Теперь вы можете установить все необходимое для запуска подсистемы Windows для Linux (WSL).
Ссылка: https://docs.microsoft.com/ru-ru/windows/wsl/install


Командная строка.
Для работы с командной строкой понадобятся две вещи:
1. Терминал.
2. Командный интерпретатор.
*
Терминал 
Терминалом называют программу, которая эмулирует поведение "железного" терминала, состоящего из клавиатуры и монитора
*
Командный интерпретатор
У этого понятия множество синонимов, среди них shell ("шелл"), командная оболочка и командный процессор. Командная оболочка — программа, через которую пользователь (или администратор) управляет операционной системой и установленными программами, используя командную строку. 
*
Символ $ используется как разделитель. Слева от него — настраиваемое сообщение для вывода, обычно текущая директория, а справа — то, что вводится пользователем.
*
# комментарии
*
Командные оболочки, как и терминалы, бывают разные, хотя по умолчанию в большинстве операционных систем стоит Bash.
Командная оболочка и терминал — не одно и то же. Терминал — это программа, которая запускает командную оболочку внутри себя.
*
Командную оболочку нередко называют реплом (REPL, Read-Eval-Print-Loop), что отражается в способе взаимодействия с пользователем:

    Read — шелл ждёт ввода команды от пользователя
    Eval — шелл исполняет введённую команду
    Print — шелл выводит результат
    Loop — возвращаемся к первому пункту
Этот процесс называется интерактивной сессией: после загрузки шелл ждёт ввода команды, затем он её исполняет, выводит результат и снова ждёт ввода команды. Так происходит до тех пор, пока не будет дана команда на выход из терминала или выключение компьютера. REPL — широко распространённый способ взаимодействия с пользователем. В следующих курсах вы увидите, что он есть и у баз данных, и у языков программирования.


Навигация
Можно сказать, что мы всегда находимся внутри какой-то директории, которую называют "рабочей", working directory. Проверяется текущая директория командой pwd.
*
 Возможно, вы знаете, что путь до файла может быть либо абсолютный, либо относительный. Абсолютный путь — это полный путь начиная от корня, в нашем случае /, а относительный — это путь, начинающийся от нашей текущей рабочей директории. Выше мы указали относительный путь. Отличить их друг от друга очень легко: если первым символом в пути идёт /, то это абсолютный путь, иначе — относительный.
Команда cd понимает и абсолютные и относительные пути.
*
Для перехода на директорию уровнем выше необходимо указать специальное значение .., и произойдёт переход на директорию уровнем выше. (cd .. или cd ../..).
Команда cd, выполненная без аргументов, перебрасывает в домашнюю директорию текущего пользователя.
Домашняя директория пользователя имеет специальное обозначение — ~ (тильда), которое в момент выполнения команды заменяется на абсолютный путь.


Интерфейс командной строки
Если в GUI (Graphical User Interface — графический интерфейс) можно взять любую незнакомую программу, запустить её, почитать названия пунктов меню, потыкать на разные кнопки и получить какой-нибудь результат, то в CLI (Command Line Interface — интерфейс командной строки) у вас нет ничего кроме названия программы и как ей пользоваться — непонятно.
*
Но что, если мы захотим посмотреть скрытые файлы и директории (в *nix-системах они начинаются с символа "точка", например .profile)? Тогда необходимо набрать ls -a
*
У команд бывают аргументы и опции (их также называют флагами). Например, в команде ls Music, Music — это аргумент, а вот в команде ls -a, -a — это опция.
   Опции всегда начинаются с одного или двух дефисов
Для просмотра полного содержимого директории Music с информацией о каждом файле достаточно набрать ls -la Music.
*
Опции указываются слева от аргументов, но иногда бывают ситуации, что они используются справа, такое чаще встречается в сложных утилитах со вложенными командами.
*
Достаточно набрать man <имя команды> — и мы попадём в режим чтения документации. В мануале содержится много полезной информации, например, описание утилиты в целом, формат её вызова, все возможные опции и даже примеры вызовов.
!!!!!!!!!!!!!!!!!!!
	Ещё полезен сайт https://explainshell.com/, в который достаточно вбить любую команду, и он покажет удобное интерактивное описание.
!!!!!!!!!!!!!!!!!!!
*
Большинство утилит имеет две версии одной и той же опции: одна из них длинная, другая — короткая. Например -v и --version в PHP.
*
$ say -o hi.aac 'Hello, World.'

Значение опции указывается через пробел от самой опции. Если значение опции содержит в себе специальные или пробельные символы, то его нужно оборачивать в кавычки, двойные или одинарные - не важно.

$ say -o 'hi.aac' 'Hello, World.'

Некоторые программы допускают использование знака = вместо пробела.

# Команда say такое не позволяет, но зато видно принцип
$ say -o=hi.aac 'Hello, World.'
*
Подобное описание есть практически у любой утилиты. Описания построены по одному и тому же принципу. Квадратные скобки [] обозначают необязательность. Например, опция -v необязательна, то же самое касается и любых других опций этой программы. Вертикальная черта | обозначает операцию "или", причём именно исключающее или. Посмотрите на последний блок [-f file | string ...]. Он означает, что say может либо произносить текст из файла, либо произносить строчку, переданную как аргумент, но не то и другое одновременно. Бывают и другие вариации описания способов вызова: значение по умолчанию, выбор из конкретных элементов, отрицание.



Файловая структура
Файловая структура *nix-систем серьёзно отличается от структуры в Windows и заслуживает отдельного внимания. Начнём с базовых понятий. Файловая структура представляет собой дерево, в узлах которого находятся директории (файлы специального типа), а в листьях — файлы.
*
Информация о любом файле или директории доступна по команде stat (file system status)
*
В Windows мы привыкли, что имя файла может быть набрано в разных регистрах, и это всегда один и тот же файл, то есть имена регистронезависимы. В *nix-системах регистр имеет значение. Файлы index.html, Index.html, INDEX.HTML и index.HTML — это разные файлы. Всегда обращайте внимание на регистр, потому что ошибиться довольно легко.
*
Говорят, что в *nix "всё есть файл". На нижнем уровне так и есть (почти). Директория — это специальный файл, который содержит список файлов. Любое подключаемое устройство становится файлом или директорией, если это накопитель.
*
В *nix-системах есть базовый набор каталогов, который стандартизирован (FHS). За каждым закреплена какая-то особая роль. Например, каталог /etc содержит конфигурацию программ в обычных текстовых файлах (в юниксах нет реестра, вся конфигурация лежит в обычных файлах), а каталог /home содержит домашние директории пользователей системы (исключением является суперпользователь root, его домашний каталог обычно находится по адресу /root). Обязательно пробегитесь по странице
!!!!!!!
https://ru.wikipedia.org/wiki/FHS
!!!!!
и посмотрите, что за что отвечает.
*
В отличие от Windows, в *nix-системах отсутствует понятие "расширение файла". Точка — полноправная часть имени. Это не значит, что в юниксах невозможно понять тип файла. Это возможно, более того, файлы почти всегда именуются так же, как и в Windows, например hello.mp3, но важно понимать, что вся эта строчка — имя файла. Нередко встречаются и такие имена: index.html.haml. В *nix также есть скрытые файлы, но, в отличие от Windows, это не свойство файла, а определённое имя файла. Все файлы и директории, начинающиеся с точки, считаются скрытыми. Вывести все файлы, включая скрытые, можно командой ls -a.
	Обратите внимание на две особые директории, обозначенные "точкой" (.) и "двумя точками" (..). Точка означает текущую директорию, а две точки — директорию верхнего уровня. Именно благодаря этой схеме работает команда cd .., которая перемещает нас на уровень выше.
*
Кроме обычных файлов, в *nix существует ряд других:

    Hard Link — дополнительное имя для уже существующего файла.
    Symbolic link — символическая ссылка, такой файл похож на ярлык в Windows. Если удалить основной файл, то символическая ссылка начнёт вести в никуда.
    Socket — специальный файл, через который происходит взаимодействие между разными процессами операционной системы. Программисты постоянно сталкиваются с сокетами в реальной жизни.



Чтение файлов
Самый простой способ прочитать файл — команда cat.
cat ожидает аргументы — пути до файлов, которые надо читать. В простейшем случае достаточно передать один путь, это довольно удобно, когда надо посмотреть содержимое небольшого файла.
*
Иногда нужно посмотреть только начало файла или его конец, в такой ситуации помогают команды head и tail. Они тоже принимают на вход путь до файла, только head показывает первые 10 строк, а tail — последние 10 строк файла. Это поведение можно менять, задавая желаемое количество строк через опцию -n.
$ head -n 2 .bashrc
$ tail -n 2 .bashrc
*
Некоторые файлы наполняются очень интенсивно. Например, так называемые "логи". Логи (иногда говорят "журналы") — это текстовые файлы, в которые заносится информация о происходящих процессах в определённой системе. В Linux логи лежат в каталоге /var/log. Туда пишет как сам Linux, так и большая часть установленных программ. Основной файл логов Linux называется syslog. Туда попадает ключевая информация о происходящих процессах в операционной системе и возникающих ошибках. Если события происходят часто и есть потребность анализировать их в процессе поступления, то команда cat оказывается неудобной, потому что syslog большой. Не подходит и простой запуск команды tail, потому что придётся запускать её каждую секунду и всё равно можно что-нибудь пропустить (если интенсивность записи событий в лог очень высокая).

В этой ситуации поможет tail, запущенный в особом режиме благодаря флагу -f. Команда tail -f path/to/file не просто выводит последние строчки файла, но ждёт появления новых. Как только файл дописывается, tail сразу выводит на экран добавленные строки. Среди наших примеров это первая команда, которая захватывает управление, то есть после запуска она не заканчивает выполнение сразу, а продолжает работать, ожидая новые данные в файле, который выводится. Для остановки её выполнения нажмите Ctrl + C.
*
Особая категория программ для просмотра содержимого файла — пейджеры. Пейджер похож на текстовый редактор, но открытый только в режиме чтения. Самый распространённый пейджер называется less. Попробуем открыть с помощью него файл syslog:
$ sudo less syslog
less открывает файл и остаётся в этом режиме. Он позволяет перемещаться по файлу вперёд и назад, производить поиск. Одна из отличительных особенностей пейджеров состоит в том, что они одинаково хорошо и быстро работают с файлами любых размеров. Всё потому, что пейджер не пытается загрузить в память весь файл до его отображения. Он грузит только ту часть, которая помещается на экран и при перемещении подгружает остальное.

less предоставляет несколько десятков команд для перемещения по тексту и его поиску, про большинство из них можно прочитать в соответствующем мануале. Здесь же затронем основные:

    q — выход
    f — вперёд на страницу
    b — назад на страницу
    если набрать /, затем начать вводить буквы и нажать Enter, то выполнится поиск введённого текста. Перемещение по найденным совпадениям выполняется командой n (переход к следующему совпадению) и командой N (переход к предыдущему совпадению).

Возможно, вы увидели сходство поведения пейджеров с тем, что мы наблюдали в мануалах. Открою секрет: когда мы запускали man, то перед нами открывался less с загруженным туда контентом. Как вы увидите позже, пейджеры невероятно популярны и неявно запускаются другими программами.



Grep
Наименование происходит от консольной утилиты grep (global regular expression print), выполняющей поиск по файлу или файлам определённого текста.
$ man grep

SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]

PATTERN — это то, что ищется, необязательно конкретная строчка, возможно определённый шаблон (см. регулярные выражения). FILE — путь до файла, в котором нужно искать
*
Найденные строчки выводятся на экран в том же порядке, в котором они встречаются в исходном файле. В некоторых ситуациях бывает важно увидеть не только саму строку, содержащую подстроку, но и то, что находится вокруг неё. Количество выводимых соседних строк регулируется опциями -B, -A и -C. Первая определяет количество отображаемых строк до искомой (-B, --before-context), вторая — после (-A, --after-context), а третья — до и после одновременно (-C, --context). Ниже пример использования -C со значением 1. Это значит, что для каждой найденной строки будет выведена одна строка выше и одна строка ниже.



Редактирование файлов
Для редактирования файлов в командной строке используют редакторы Nano, Vim и Emacs. В большинстве случаев в системе установлен только Vim, поэтому крайне важно владеть базовыми навыками обращения с ним. Эти редакторы запускаются прямо в терминале, хотя Vim и Emacs имеют режим, в котором они запускаются как отдельные приложения.


Nano

Nano очень простенький текстовый редактор, похожий на "блокнот" в Windows, хотя по возможностям он богаче и даже способен подсвечивать содержимое файлов.

$ nano .bashrc

После запуска редактора внизу открывается панель с подсказками, какие горячие клавиши доступны для использования. Символ ^ означает клавишу Ctrl. Например, для выхода из редактора нужно набрать Ctrl + x, а затем либо подтвердить сохранение изменений, либо отвергнуть, нажав y (yes) или n (no). В принципе, больше ничего интересного про nano сказать нельзя. Редактор и редактор. Подходит для несложных изменений в файлах, но совсем неудобен для работы над многофайловыми проектами, да ещё и с кодом.


Vim

Совсем другое дело Vim (Vi Improved или улучшенный vi) — свободный текстовый редактор, созданный на основе более старого vi (visual editor). Это редактор-комбайн, который, к тому же, имеет абсолютно непохожую ни на что другое модель работы.

$ vim .bashrc

Ключевое отличие (а их много!) вима от остальных редакторов — в наличии режимов. В обычных редакторах, после того как открылся файл, можно сразу приступать к редактированию. Вим после открытия работает в режиме команд (COMMAND): нажатие на любую клавишу воспринимается как сигнал к какому-то действию. Если вы не знаете команд, то лучше ничего не трогать, иначе на экране начнётся хаос. Обычное редактирование текста выполняется в режиме ввода (INSERT) и попасть в него можно нажав клавишу i. Для выхода в режим команд достаточно нажать Esc (или комбинацию Ctrl + [).

 С другой стороны, чем дальше вы будете продвигаться по стезе программиста, тем больше вы начнёте замечать, что опытные и многие известные программисты предпочитают разрабатывать целиком и полностью в виме. Посмотрев на вим без плагинов, сложно в это поверить, но он становится очень навороченным благодаря расширениям. Подробнее о том, почему так происходит и что особенного в виме, написано в нашем руководстве. Крайне рекомендую к прочтению. (https://guides.hexlet.io/vim/)

Говорят, что самое сложное в виме — это выйти, поэтому подготовимся заранее. Убедитесь, что вы находитесь в командном режиме, на всякий случай нажмите Esc (или комбинацию Ctrl + [). Затем наберите :, эта команда переведёт вас в режим командной строки (ещё один режим), затем введите q! и нажмите Enter. Так вы выйдете из вима без сохранения изменений. Если набрать :wq, то перед выходом сохранятся все изменения. Если вы хотите просто сохраниться без выхода, то наберите :w.

В Vim есть четыре основных режима работы:

    Командный режим (обычный режим) — это режим по умолчанию. Перемещение по файлу, быстрое (при помощи команд, комбинаций клавиш) редактирование, удаление, поиск текста.
    Режим вставки (режим ввод) — ввод текста с клавиатуры. То, как вы привыкли это делать в обычных редакторах.
    Визуальный режим — выделение произвольных участков текста.
    Режим командной строки — собственная командная строка для редактора текста, из которой можно выполнять великое множество разнообразных команд.

Кстати, большая часть Хекслета как платформы и почти весь текстовый контент (курсы) сделаны именно в виме. Включая эту строчку ;)



Потоки
При старте любой программы операционная система связывает с ней три так называемых потока: STDIN (Standard Input), STDOUT (Standard Output) и STDERR (Standard Error). Для языка программирования они выглядят как файлы, и взаимодействие с ними происходит как с файлами. STDOUT как раз отвечает за вывод на экран. Каждый раз, когда в программе (на любом языке) происходит печать на экран, функция печати, на самом деле, записывает с помощью функции write данные в STDOUT, а вот уже операционная система решает куда вывести результат. По умолчанию вывод происходит на экран терминала.

 ОС позволяет подменять эти потоки при старте системы, что открывает интересные возможности. Например, вывод любой команды, запущенной в bash, можно записать в файл вместо вывода на экран.

$ ls -la > output

Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в текущей директории появился файл output.

Операция, которую мы сделали выше, называется перенаправление потоков. Символ > означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. > всегда перезаписывает файл. Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.

$ grep alias .bash_profile > result
$ cat result
alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'

Если нужно не перезаписывать, а добавлять, то используйте >>.

Для экспериментов с выводом удобно использовать встроенную в шелл команду echo. Она принимает на вход строчку и выдаёт её в STDOUT, который уже можно перенаправлять.

Кроме стандартного вывода, с каждым процессом ассоциируются два дополнительных потока: один STDIN (стандартный ввод) и STDERR (вывод ошибок). STDIN работает в обратную сторону: через него программа может получать данные на вход. В *nix-системах встроена утилита wc (word count — "количество слов"), которая умеет считать количество слов, строк или символов в файле. Когда мы говорим о файле, то в *nix это почти всегда означает, что данные можно передать и в стандартный поток ввода.

# Флаг l (l а не 1) говорит о том, что надо считать количество строк
$ wc -l < result
2

Выглядит довольно логично — стрелка меняет своё направление в другую сторону и содержимое файла отправляется в STDIN запускаемой программы wc. Теперь сделаем финт и объединим перенаправление ввода и вывода.

$ wc -l < result > output
$ cat output
$ 2

Последний вопрос связан с тем, зачем нужен поток STDERR. Он, как и STDOUT, по умолчанию идёт на экран. STDERR позволяет отделить нормальный вывод программы от возникающих ошибок. Такой подход удобен при ведении логов, для реагирования и отладки. Будьте осторожны, перенаправление вывода в файл перенаправляет только STDOUT. Убедиться в этом очень просто. Если попробовать перейти в несуществующую директорию, то команда cd выдаст ошибку:

$ cd lala
-bash: cd: lala: No such file or directory

Теперь попробуем перенаправить вывод в файл output

$ cd lala > output
-bash: cd: lala: No such file or directory

Перенаправление есть, но сообщение вывелось на экран. Это произошло именно по той причине, что STDERR остался привязан к экрану, а внутри файла output — пустота. Решить эту задачу можно несколькими способами. Например, перенаправив STDERR в STDOUT, либо отправив их оба в файл.

!!!!Перенаправление STDERR в STDOUT!!!!

# Сначала STDERR перенаправляется в STDOUT, затем STDOUT в файл
$ cd lala > output 2>&1
$ cat output
-bash: cd: lala: No such file or directory

2 в данном случае обозначает номер потока. В POSIX за каждым потоком закреплён определённый номер, который является файловым дескриптором, если быть точным: STDIN — 0, STDOUT — 1, STDERR — 2. Конструкцию 2>&1 нужно просто запомнить, она говорит о том, что поток с номером 2 отправляем в поток с номером 1.

Перенаправление STDERR бывает полезно само по себе, без вывода в файл.

#  STDERR просто перенаправляется в другой поток (STDOUT)
$ cd lala 2>&1
-bash: cd: lala: No such file or directory

!!!!Перенаправление конкретного потока в файл!!!!

Чтобы перенаправить конкретный поток, нужно указать его номер перед >.

#  Таким образом можно сразу перенаправить STDERR в файл
$ cd lala 2> output
$ cat output
-bash: cd: lala: No such file or directory

!!!!Перенаправление обоих потоков в файл!!!!

Этот вариант используется наиболее часто, так как помогает легче проводить отладку и понимать почему вообще возникла та или иная ошибка.

# Оба потока, STDERR и STDOUT, перенаправляются в файл
$ cd lala &> output
$ cat output
-bash: cd: lala: No such file or directory



Пайплайн (Конвейер)

Раз у одного процесса есть вход, а у другого — выход, и их можно подменять, то логично предположить, что их можно соединить. Данный подход носит название pipeline (конвейер). Благодаря пайплайну можно соединять программы и протаскивать данные сквозь них, как сквозь цепочку функций, каждая из которых выступает в роли преобразователя или фильтра.

Когда мы грепали, то делали это по какому-то одному слову, но часто возникает задача грепать по нескольким словам. Не важно, как они расположены внутри строки, главное, что они встречаются там вместе. Такую функциональность можно было бы сделать, усложнив саму программу grep. Но пайплайн позволяет добиться такого же поведения без необходимости писать сложную программу.

$ grep alias .bashrc | grep color
# enable color support of handy aliases
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

| — этот символ называется пайп, он указывает шеллу взять STDOUT одного процесса, и соединить его с STDIN другого процесса. Поскольку grep принимает на вход текст (как я говорил в прошлом уроке, все утилиты, которые читают файлы, могут принимать данные через STDIN) и возвращает текст, то его можно комбинировать бесконечно.

Запись grep alias .bashrc | grep color можно изменить, используя перенаправление. Так она станет проще для модификации:

$ cat .bashrc | grep alias | grep color

В примере выше файл читается катом и отправляется в STDIN грепа.

cat source | grep Dog | uniq | sort

    1.Читается файл source
    2.Входные данные грепаются по подстроке "Dog"
    3.Убираются дубли (в исходном файле две одинаковых строки "Dog")
    4.Входные данные сортируются и выводятся на экран

Пайплайн стал основой философии Unix, которая звучит так:

   - Пишите программы, которые делают что-то одно и делают это хорошо.
   - Пишите программы, которые бы работали вместе.
   - Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.

Именно поэтому большинство утилит работают с сырым текстом — принимают его на вход и возвращают в STDOUT. Такой подход позволяет получать сложное поведение из крайне простых составных блоков. Такая концепция называется стандартные интерфейсы и хорошо отражена в конструкторах Lego.



Манипулирование файловой структурой
Файловую структуру можно не только просматривать, но и всячески модифицировать. В прошлом уроке мы научились создавать файлы через перенаправление потоков, но всё это можно делать и напрямую.

Учтите, что возможность модифицировать файловую структуру завязана на права пользователя. Если у вас нет соответствующих прав, вы получите ошибку доступа. Место, где вы гарантированно можете экспериментировать — ваша домашняя директория. Внутри неё всё доступно на запись.

Для создания файлов принято использовать утилиту touch.

Основная задача утилиты — поменять время последнего доступа к файлу, но она обладает побочным эффектом. Если файла не существует, то он будет создан — именно поэтому её используют для создания файлов, хотя это не основное предназначение.

# В текущей директории создаётся пустой файл
touch empty-file

Удаляется файл командой rm (remove files):

rm empty-file

В *nix-системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению, которое выполняется командой mv (move)

touch file
mv file renamed-file

Для копирования файлов и директорий используется утилита cp (copy). Её первый аргумент — имя источника (откуда), второй — имя приёмника (куда).

cp renamed-file renamed-file-copy

Для копирования директории нужно добавить флаг -r (recursive).

Все эти и последующие утилиты работают с файлами и директориями, расположенными в любом месте файловой системы. Поэтому вы всегда можете передать любой путь: touch /tmp/tempfile.

Утилиты для работы с директориями частично отличаются. Создание директории выполняется командой mkdir (make directory).

mkdir my-dir

По умолчанию эта команда не создаёт вложенных директорий:

mkdir one/two/three
mkdir: cannot create directory ‘one/two/three’: No such file or directory

В такой ситуации придётся либо создавать каждую директорию отдельно, либо воспользоваться флагом -p, который создаёт директории рекурсивно.

mkdir -p one/two/three

Удаление директорий выполняется той же командой, что и удаление файлов, но без флагов оно выдаёт предупреждение:

rm my-dir/
rm: cannot remove 'my-dir/': Is a directory

Чтобы не было ошибки, нужно добавить флаг -r. Он включает режим рекурсивного (r — recursion) удаления содержимого директорий, то есть идёт просмотр всего, что внутри во всех вложенных директориях и поддиректориях (до самого конца).

rm -r my-dir

Если внутри директории содержатся файлы или директории с ограниченными правами доступа, например, доступные только для чтения, то команда rm начнёт задавать вопрос по каждому из них, нужно ли его удалять. Если вы точно уверены, что удалить нужно всё, добавьте флаг -f(или --force) - этот флаг позволяет игнорировать несуществующие файлы и не запрашивать подтверждение на удаление. В таком случае rm удалит всю директорию без вопросов.

rm -rf one



Переменные окружения

Напомним, что команда cd без аргументов делает домашнюю директорию пользователя рабочей (working directory). Возникает вопрос, каким образом она узнаёт о том, где находится домашняя директория? Можно предположить, что команда cd каким-то образом обращается к операционной системе и узнаёт у неё эту информацию или смотрит напрямую в конфигурационных файлах. Но ни первого, ни второго она не делает. Эта команда ориентируется на так называемую переменную окружения. Переменные окружения похожи на переменные в языках программирования. Они существуют в рамках запущенной сессии командного интерпретатора, подгружаются туда во время его инициализации (но это не единственный путь их появления). Посмотреть установленные переменные можно командой env (environment). Ниже неполный список этих переменных, которые доступны на одном из серверов Хекслета.

Формат вывода очень простой: слева от знака равно расположено имя переменной, справа — значение. Вывод команды env в вашем случае будет отличаться не только значениями этих переменных, но и их составом. Например, у вас точно не будет HEXLET_VERSION, но наверняка будет HOME, только с другим значением.

Основное предназначение переменных окружения — конфигурирование системы и программ. Их удобство заключается в универсальности и отвязке от способа появления этих значений в системе. Возьмём ту же cd. Эта команда знает лишь то, что домашняя директория доступна в переменной окружения HOME. Как она попала в систему — не важно. Без переменной окружения пришлось бы делать одну из двух вещей:

    При вызове cd каждый раз указывать, где находится домашняя директория. Например, так: cd --home-dir /home/kirill.m. Но такой способ убивает весь смысл быстрого перехода в домашнюю директорию.
    Договариваться о том, что где-то будет храниться специальный файл с настройками (в том числе домашней директории), которые будут читаться командой cd при каждом запуске.

Существует некоторый базовый набор переменных, которые всегда устанавливаются bash при старте. Они используются большим количеством утилит и нужны для нормального функционирования системы. Одну из таких переменных мы уже знаем — это HOME.

# Для вывода переменной используется echo,
# а перед самой переменной ставится знак $.
$ echo $HOME
/home/kirill.m
# Для установки знак $ не нужен.
# Очень важно чтобы не было пробелов вокруг знака равно
$ HOME=/tmp
$ echo $HOME
/tmp
# Возвращаем обратно
HOME=/home/kirill.m
$ echo $HOME
/home/kirill.m
# Возвращаем обратно

Теперь проведём эксперимент: попробуем установить HOME и выполнить переход в эту директорию с помощью команды cd, которая должна отправить нас в домашнюю директорию.

# Достаточно выполнить присваивание слева от запускаемой команды
$ HOME=/tmp cd
/tmp
$ pwd
/tmp

Команда cd выполнила переход по пути, указанном в переменной HOME. Теперь снова сделаем cd, но не добавляя определение переменной слева.

$ cd
$ pwd
/home/kirill.m
$ echo $HOME
/home/kirill.m

В этот раз произошёл переход в настоящую домашнюю директорию. Получается, что вызов HOME=/tmp cd изменил переменную только для того конкретного запуска. И действительно, существует два способа задавать значение переменной окружения: локальный и глобальный. Когда мы указали HOME=/tmp прямо перед командой cd, то переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd. Такой трюк можно проделывать с любой командой. Другой способ установки изменяет значение глобально, для всей сессии и выполняется так:

$ echo $HOME
/home/kirill.m
$ export HOME=/tmp
$ cd
$ pwd
/tmp
$ echo $HOME
/tmp

Обратите внимание на то, что изменение происходит в рамках текущей сессии, другими словами, если у вас открыто две вкладки терминала, и в каждой загружен bash, то изменение произойдёт только в той вкладке, в которой будет выполнена команда.



История

Чем больше работаешь в командной строке, тем чаще возникает необходимость повторять введённые ранее команды. Самый простой способ просматривать историю команд — нажимать клавиши "вверх/вниз". При каждом нажатии стрелки "вверх" в поле ввода начнёт появляться предыдущая выполненная команда, если нажать "вниз" — то следующая.

История команд bash хранится в специальном файле .bash_history, который лежит в домашней директории пользователя. Каждый раз, когда пользователь вводит команду, она попадает именно в этот файл. Он ничем не отличается от остальных файлов: его можно открыть, посмотреть и даже отредактировать. За то, какое количество команд хранится в истории, отвечает переменная окружения HISTFILESIZE. Если она выставлена, то берётся указанное в ней число, иначе история не обрезается и файл .bash_history растёт "бесконечно".

Посмотреть историю можно и более простым способом, достаточно выполнить команду history.

Эта команда выведет содержимое файла .bash_history, добавив слева номер. Если набрать history 5, то отобразятся только 5 последних введённых команд. Используя номер команды в выводе history, можно выполнить повторный запуск без необходимости набирать или копировать команду из истории.

$ !2
# Эта команда имела второй номер в листинге выше

При необходимости историю всегда можно погрепать:

$ history | grep export
  174  export HOME=/tmp
  183  history | grep export

Последнее, и самое интересное — реверсивный поиск. Если нажать комбинацию Ctrl + r, то запустится специальный поиск по истории. Он ожидает ввода символов и сразу отображает ближайшую команду, в которой эти символы встречаются. Если найденное соответствие вас не устроило, то повторное нажатие Ctrl + r выберет следующее соответствие из истории.



Пользователи и группы

Тема пользователей и их прав в системе в первую очередь относится к функционированию самой операционной системы. Оболочка лишь предоставляет утилиты, позволяющие анализировать доступы и изменять их.

Взаимодействие с операционной системой всегда ведётся от какого-то конкретного пользователя, созданного в системе. Команда whoami позволяет выяснить, кто же я такой:

$ whoami
kirill.m

Абсолютно любой процесс, запускаемый в операционной системе, стартует от имени некоторого пользователя. Соответственно, его возможности по влиянию на файловую систему ограничены теми правами, которые есть у пользователя, от имени которого процесс запущен. Обратите внимание на то, что я говорю не "пользователь запустил процесс", а "процесс запускается от имени пользователя". Дело в том, что присутствие пользователя для запуска необязательно. Да, работая в командной строке мы запускаем всё сами, но когда система загружается, то она запускает множество различных процессов и, как мы увидим ниже, для многих из них создаются собственные пользователи с ограниченным набором прав.

Команда ps (process status) выводит отчёт о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода ps aux:

$ ps aux
# Левый столбец имя пользователя

Взаимодействие с файловой системой происходит через запуск тех или иных утилит, модифицирующих, создающих или анализирующих файловую структуру. Это значит, что запуская, например, touch, мы стартуем процесс от своего имени, внутри которого запускается программа touch. Она, в свою очередь, создаёт файл (если его не было) и делает вас владельцем нового файла. Кстати, модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории пользователя всё принадлежит пользователю (хотя, если постараться, то можно навертеть как угодно):

$ ls -la

Третий столбец в этом выводе — как раз владелец. Единственная запись, которая выбивается из всего списка это .., то есть родительская директория. Её владельцем является root, о котором мы позже поговорим. Если хорошо подумать, то это логично — ведь директория /home не является собственностью пользователей системы:

$ ls -la /home/

Каждый каталог в директории /home является домашним каталогом конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.

Имя пользователя в системе должно быть уникальным, но его можно менять. Если посмотреть под капот работы этой системы, то мы увидим, что имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя. Если поменяется имя пользователя, но идентификатор останется прежним, то все доступы останутся. Если же сменится идентификатор, то фактически сменится и пользователь. Соответственно, новый пользователь потеряет доступы ко всему старому. Посмотреть свой идентификатор можно разными способами. Первый способ — с помощью команды id:

$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

Второй способ связан с просмотром одного важного файла, который является основным хранилищем пользователей в *nix-системах. Да, это обычный текстовый файл, как и всё остальное.

$ cat /etc/passwd

Кроме имени и идентификатора, здесь также указана домашняя директория пользователя (и её можно поменять), а также шелл по умолчанию. Запись /usr/sbin/nologin говорит о том, что данный пользователь не может входить в систему. Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.

Кроме имени, у пользователей *nix-систем есть связанное с ним понятие группа. Группа, как можно догадаться из названия, создана для группового доступа к разделяемому (общему) ресурсу (например, файлу). Например, у нас есть группа разработчиков, которые регулярно ходят на сервер, и им нужно дать одинаковые возможности по управлению определёнными файлами. Так как владелец у файла ровно один, то мы не можем решить этот вопрос через смену владельца, но можем через создание группы. Достаточно её создать и привязать к самому пользователю. Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:

$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

Здесь группа kirill.m является основной, такая группа может быть только одна, и именно в эту группу входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп. То, как это влияет на доступы, мы рассмотрим в одном из следующих уроков.

В любой *nix-системе присутствует специальный пользователь root, или, как говорят, суперпользователь. Главная его особенность — это идентификатор со значением 0 (а имя в теории можно поменять). Этот пользователь имеет особое значение для системы и может выполнять абсолютно любые действия в системе. У пользователя root в файле /etc/passwd будет вот такая запись:

Крайне не рекомендуется использовать этого пользователя на регулярной основе. И ни в коем случае нельзя входить под ним в систему. root — это прямой доступ ко всему и большая дыра в безопасности системы. Кроме того, систему очень легко убить, например, удалив случайно не тот файл или испортив важную конфигурацию, после чего вход в систему станет невозможным.

Несмотря на это, root нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям. Об этом мы поговорим в следующем уроке.



Sudo

Ситуаций, в которых необходимо повышать привилегии и выполнять команды от имени суперпользователя (root), довольно много. С некоторыми мы уже столкнулись, с другими познакомимся в следующих уроках:

    Установка новых программ
    Навигация по чужим директориям
    Изменение прав доступа и владельцев файлов, не принадлежащих текущему пользователю
    Создание, редактирование и удаление файлов в местах, где не хватает прав текущего пользователя
    Запуск программ, требующих повышенные привилегии

Стать другим пользователем, находясь прямо в системе, можно с помощью утилиты su (substitute user, switch user). Когда-то такой способ был основным, но сейчас он устарел и крайне не рекомендуется к использованию. Подробнее об этом можно прочитать в статье из дополнительных материалов. Основной способ повышать привилегии в современных системах — утилита sudo (substitute user and do — дословно "подменить пользователя и выполнить").

Использовать sudo очень просто, достаточно написать эту команду слева от любой другой и выполнить. По умолчанию она пытается повысить привилегии до суперпользователя:

# Нет прав на выполнение
$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

# С sudo все работает
$ sudo touch /etc/myfile

# Видно что владелец файла root
$ stat /etc/myfile
  File: '/etc/myfile'
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: ca01h/51713d    Inode: 2761        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)

# Нет прав на удаление
$ rm /etc/myfile
rm: remove write-protected regular empty file '/etc/myfile'? y
rm: cannot remove '/etc/myfile': Permission denied

# Опять помогло sudo
$ sudo rm /etc/myfile
$

В зависимости от настроек sudo в системе эта утилита может попросить ваш пароль для входа либо вообще откажется работать, сказав, что у вас нет права её использовать. Как правило, в Ubuntu sudo спрашивает пароль и запоминает его на 5 минут. На протяжении этого времени вы можете использовать sudo, не вводя пароль каждый раз.

Иногда бывает нужно выполнить команду из-под пользователя, отличного от root. Тогда придётся добавить флаг -u:

$ sudo -u nobody mkdir /tmp/test
# Файл создан от nobody

Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую сессию поверх текущей:

$ sudo -i
$ id
uid=0(root) gid=0(root) groups=0(root)

Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit.

Подводные камни

Знание про sudo играет с новичками злую шутку. Каждый раз, когда они видят "странные" ошибки, то не пытаются разобраться, а пробуют запустить команду с sudo без параметров, то есть просто выполнить её от суперпользователя. Часто такой подход срабатывает, но он создаёт ещё больше проблем, чем решает.

Запуск команды, которая создаёт файлы и директории из-под sudo, приводит к тому, что владельцем этих файлов становится пользователь root. Фактически все последующие обращения к этому файлу без sudo начнут выдавать ошибку об отсутствии прав доступа. Причём даже необязательно работать с этими файлами напрямую: множество программ так или иначе обращаются к файловой системе для чтения конфигурационных и других файлов.

Правильный выход из ситуации в каждом случае свой. В некоторых случаях sudo это то, что нужно, но иногда требуется изменить права (об этом в следующем уроке), а иногда и переустановить какую-нибудь часть системы.

Наиболее общее правило может быть таким: всё, что лежит в личных директориях пользователя, должно принадлежать пользователю, а не суперпользователю. Всё, что требует дополнительных прав, так как находится в системных путях (вне домашней директории пользователя), скорее должно запускаться с sudo (но это необязательно).

 ~$ ls -la
# Всё содержимое домашней директории принадлежит одному пользователю.
# Сама директория пользователя принадлежит ему же,
# а родительская директория принадлежит суперпользователю 



Права доступа

Частая ошибка, с которой встречаются разработчики — ошибка доступа:

$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

Она говорит о том, что текущий пользователь не имеет прав на создание файлов в каталоге /etc. Почему? Давайте разбираться.

Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: r — чтение, w — запись и x — исполнение. Причём эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и остальных (Other) — тех, кто не попал в предыдущие две. Разберём на примере:

# Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc

Запись слева представляет из себя один из вариантов описания прав доступа (permissions). Для удобства чтения разделим эту запись на группы символов - rw- r-- r--. Первый символ - в этой записи говорит о том, что перед нами файл. За ним следует три группы, в каждой из которых по три символа. Каждая группа описывает доступы для разных типов пользователей. Первая описывает права доступа для владельца файла. rw- означает, что владелец этого файла может как читать (r) этот файл, так и писать (w) в него. Последний прочерк означает, что этот файл нельзя исполнять. Исполнение описывается символом x и будет рассмотрено в следующем уроке. Не важно, какой файл или директорию мы смотрим — порядок прав в этой группе всегда один и тот же чтение-запись-исполнение, а прочерк означает отсутствие данного права.

Следующая группа прав относится к тем, кто входит в группу kirill.m, так как именно этой группе принадлежит данный файл. Запись r-- говорит о наличии доступа только для чтения, а изменение запрещено. То же самое касается и тех, кто не входит в эту группу, то есть набор прав у последних двух одинаковый.

Попробуйте ответить на вопрос с подвохом: а кто может удалить этот файл? Для ответа на этот вопрос важно знать владельца, группу и права той директории, в которой лежит файл .bashrc. Сам файл не может обозначить прав на своё удаление, они всегда берутся из того места, где он находится. Удалить файл можно только, если у вас есть возможность писать в эту директорию (в соответствии с тем, к какому типу пользователей вы относитесь).

$ ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m

Попробуйте ответить на вопрос с подвохом: а кто может удалить этот файл? Для ответа на этот вопрос важно знать владельца, группу и права той директории, в которой лежит файл .bashrc. Сам файл не может обозначить прав на своё удаление, они всегда берутся из того места, где он находится. Удалить файл можно только, если у вас есть возможность писать в эту директорию (в соответствии с тем, к какому типу пользователей вы относитесь).

$ ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m
Попробуйте ответить на вопрос с подвохом: а кто может удалить этот файл? Для ответа на этот вопрос важно знать владельца, группу и права той директории, в которой лежит файл .bashrc. Сам файл не может обозначить прав на своё удаление, они всегда берутся из того места, где он находится. Удалить файл можно только, если у вас есть возможность писать в эту директорию (в соответствии с тем, к какому типу пользователей вы относитесь).

$ ls -la /home/ | grep kirill
drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m

Домашняя директория имеет другие права. Первое отличие — это d вместо - в самом начале. d говорит о том, что перед нами директория. Права для владельца rwx, а для всех остальных r-x. Из этого описания видно, что кроме пользователя никто не может писать внутрь домашней директории этого пользователя.

Что такое x в отношении директорий? Это право позволяет перемещаться в директорию и обращаться ко всем расположенным в ней файлам и каталогам. Обращаться можно при условии, что эти файлы доступны на чтение, или запись, или выполнение: например, если положить доступный на чтение файл в директорию с правом x, то вы сможете прочитать этот файл. Если же убрать с директории право x, то вы вовсе лишитесь доступа к файлу.

Но что тогда такое чтение? Здесь всё более интуитивно понятно: директория, по сути, является списком файлов, поэтому право на чтение позволяет прочитать этот список файлов, а именно вывести список имён файлов, содержащихся в директории. Однако, если хотите посмотреть не простой список имён файлов, а список с дополнительной информацией (как при выводе ls -l), то требуется ещё и право x, потому что в этом случае надо обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). В любом случае, без права r на каталог вы не сможете посмотреть его содержимое.

В литературе (статьях, книгах, руководствах) иногда используется другой способ описания прав доступа: 755. Это не одно число, а три числа, каждое из которых представляет собой группу rwx для наших типов пользователя в том же порядке: для владельца, входящих в группу и всех остальных. 0 — означает, что нет никаких прав для данного типа пользователей.

A 	B 	C 	D
# 	Permission 	rwx 	Binary
7 	read, write and execute 	rwx 	111
6 	read and write 	rw- 	110
5 	read and execute 	r-x 	101
4 	read only 	r-- 	100
3 	write and execute 	-wx 	011
2 	write only 	-w- 	010
1 	execute only 	--x 	001

drwxr-xr-x в числовой форме соответствует 755, а -rw-r--r-- — 644.

Однако пользователь root находится вне этой системы. Для него не имеет никакого значения наличие любых прав — суперпользователь может всё.

chown (от англ. change owner) — UNIX‐утилита, изменяющая владельца и/или группу для указанных файлов. В качестве имени владельца/группы берётся первый аргумент, не являющийся опцией. Если задано только имя пользователя (или числовой идентификатор пользователя), то данный пользователь становится владельцем каждого из указанных файлов, а группа этих файлов не изменяется. Если за именем пользователя через двоеточие следует имя группы (или числовой идентификатор группы), без пробелов между ними, то изменяется также и группа файла. При стандартной настройке сервера команда вызывает сброс накопленных кэшей (событие touch). 

chmod (от англ. change mode) — команда для изменения прав доступа к файлам и каталогам, используемая в Unix-подобных операционных системах. Входит в стандарт POSIX, в Coreutils.

Синтаксис:

    chmod [options] mode[,mode] file1 [file2 ...]

Опции:

    -R рекурсивное изменение прав доступа для каталогов и их содержимого
    -f не выдавать сообщения об ошибке для файлов, чьи права не могут быть изменены.
    -v подробно описывать действие или отсутствие действия для каждого файла.

Команда никогда не изменяет права на символьные ссылки; однако для каждой символьной ссылки, заданной в командной строке, изменяет права доступа связанного с ней файла. Команда игнорирует символьные ссылки, встречающиеся во время рекурсивной обработки каталогов.

Аргумент команды chmod, задающий разрешения, может быть записан в двух форматах: в числовом и в символьном. 



Пакетный менеджер

Привычный способ ставить программы для Windows-пользователя — бродить по интернету в поисках нужных приложений. В *nix-системах такой способ хоть и используется, но значительно реже. Для установки программ, особенно связанных с разработкой, придумали пакетные менеджеры.

В некоторых операционных системах есть пакетный менеджер по умолчанию, в других отсутствует и его надо устанавливать самостоятельно:

    macOS - brew
    Windows - Chocolatey

Далее, для всех примеров будет использоваться пакетный менеджер apt, который поставляется с Ubuntu. Например, установка PHP в Ubuntu выглядит так:

# Требует sudo, потому что установка идет в системные директории
$ sudo apt install php
# Здесь будет много текста и вопрос, устанавливать ли? Если да, то установится PHP
$ php -v

Пакетный менеджер состоит из нескольких частей. Одна из них взаимодействует с пользователем напрямую — это консольная утилита apt. Для установки необходимой программы нужно набрать apt install и далее указать её имя. Почти всегда пакетные менеджеры требуют запуска от суперпользователя (root), так как установка программ происходит в системные директории, недоступные для записи обычному пользователю (но это не всегда так, в macOS не нужно использовать sudo).

Установленные пакеты можно удалять. Для этого используется команда apt remove:

$ apt remove php
# Тут тоже много вывода и вопрос, удалять ли?

На другом конце провода находится каталог так называемых пакетов. Во время попытки установить программу утилита apt выполняет запрос в каталог и пытается понять, есть ли там пакет с таким именем. Если его нет, то вы об этом узнаете:

# Пакета wrongname не существует
$ sudo apt install wrongname
Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package wrongname

Для экономии ресурсов (сети) и ускорения работы apt сохраняет индекс (список пакетов в каталоге) на локальный диск и использует его для своей работы. Иногда это может приводить к ситуациям, что пакет в реальности существует, но apt утверждает обратное. Если вы чувствуете подвох, то запустите ручное обновление локального индекса:

$ sudo apt update
# Теперь можно устанавливать
$ sudo apt install php

После прочтения первой части у вас должно возникнуть как минимум три вопроса:

   1. Как узнать какой пакет ставить?

    Когда появляется необходимость установить определённую программу, то самый очевидный способ сделать это, найти сайт программы и выполнить действия, указанные на странице "Скачать" (обычно Download). Как правило, на этой странице есть указание о том, как можно использовать пакетный менеджер, с примерами команд, включающих в себя названия пакета. Пример: Node.js.

    Другой способ: загуглить статьи в стиле php install ubuntu. В таких статьях установка всегда идёт через пакетный менеджер. Со временем вы запомните имена многих пакетов и сможете ставить их "на автомате".

    2. Чем пакет отличается от программы?

    Сама программа ничего не знает про существование пакетного менеджера. Но чтобы её можно было ставить через менеджер пакетов, она должна быть специальным образом "упакована". Это может сделать как автор программы, так и энтузиасты. В Ubuntu используется специальный формат пакетов, называемый deb. У этого формата есть подробная документация о том, как производить упаковку.

    3. Как программы попадают в каталог?

    А вот здесь всё сильно зависит от политики тех, кто его поддерживает. В некоторые каталоги попасть очень тяжело и программы в них обновляют медленно. Связано это с тем, что разработчики стараются добавлять туда только проверенный софт. В других всё происходит просто и быстро. В любом случае необходимо пройти некоторую процедуру, после которой программа будет добавлена. Это один из ключевых аспектов, по которому дистрибутивы Linux отличаются друг от друга. В любом случае эти каталоги огромны, в них входят десятки и сотни тысяч программ и библиотек.

Пакетные менеджеры не являются прерогативой операционных систем: любая экосистема, внутри которой возможно распространение библиотек или программ, имеет свой пакетный менеджер. Пакетные менеджеры есть у всех языков программирования, иногда несколько, большинство из них включены в языки по умолчанию. В Node.js (серверный JavaScript) пакетный менеджер npm, в PHP — Composer, в Ruby — RubyGems, в Python — pip.



Выполнение программ

Запуск программ в командной строке активирует целый механизм по поиску и выполнению этой программы. Очень важно понимать, как он работает, так как проблемы с запуском вновь установленных программ возникают регулярно у всех разработчиков.

Программа, независимо от того, что она делает, всего лишь файл или набор файлов на диске. Один из этих файлов обязательно должен быть исполняемым. Помните тот самый x из урока про права доступа? Так вот, выполнить программу можно только если она исполняемая, иначе попытка запустить её приведёт к ошибке.

Весь механизм по запуску программ в *nix-системах основан на соглашениях. Когда в командной строке вводится некоторая команда, например, ls, то шелл начинает поиск исполняемого файла с именем ls в списке директорий, указанном в переменной окружения PATH.

~$ echo $PATH
/home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Директории друг от друга отделяются двоеточием. В этом списке присутствуют как общесистемные пути, так и пути, специфичные для конкретного пользователя. В вашем случае PATH будет другой. Процесс поиска программы выглядит следующим образом. Шелл перебирает директории слева направо и ищет ту, в которой есть файл ls, доступный для исполнения. Если такого файла не оказалось, то выводится ошибка:

~$ wrongname
bash: wrongname: command not found

Подчеркну, что важен порядок. Если файл с одним и тем же именем находится одновременно в нескольких директориях, то будет найден тот, который находится в директории, расположенной левее.

Если вам интересно узнать, а где лежит исполняемый файл конкретной программы, то можно воспользоваться командой type (а ещё which и whereis):

~$ type cp
cp is /bin/cp
~$ whereis cp
cp: /bin/cp
~$ which cp
/bin/cp
~$ ls -al /bin | grep cp
-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp

По выводу выше видно, что cp принадлежит суперпользователю, но исполнять его могут все.

Обратите внимание на то, что почти все директории, в которых хранятся исполняемые файлы программ, оканчиваются на bin. Это общее соглашение, говорят "бинарники" (формально там не всегда бинарники, но это не принципиально). Пакетные менеджеры знают про эти директории и во время установки программ переносят их бинарники в одну из директорий, входящих в PATH. Для вновь устанавливаемых программ обычно это /usr/local/bin. Иногда возникает необходимость расширить PATH, особенно в случае установки через пакетные менеджеры языков программирования, но делать это надо осторожно, убедившись в том, что по-другому нельзя.

В некоторых ситуациях программа, которую вы хотите запустить, не лежит по путям поиска (прописанным в PATH) и не должна там оказаться. Если её исполняемый файл находится прямо в текущей директории, то логично предположить, что если набрать имя файла и запустить его, то программа выполнится. На самом деле этого не произойдёт.

Такое поведение сделано в целях безопасности. Ведь возможно вы хотели запустить какую-то стандартную программу, а злоумышленник положил в текущую директорию программу с таким же именем, но делающую что-то плохое. По этой причине, прямой запуск программ всегда должен быть путём до файла, например path/to/executable/file. А если файл лежит в текущей директории? Вот тут-то нам и поможет обращение через точку ./:

~$ pwd
/home/hex
~$ cd test/
~/test$ ls -al
total 16
drwxr-xr-x 2 hex hex 4096 Sep 10 15:24 .
drwxr-xr-x 1 hex hex 4096 Sep 10 15:24 ..
-rwxr-xr-x 1 hex hex   60 Sep 10 15:24 executable
~/test$ executable
bash: executable: command not found
~/test$ ./executable
Hello from executable!
~/test$


   1. Из домашней директории переходим в каталог test.
   2. В нём лежит исполняемый файл executable, который при запуске выводит сообщение Hello from executable!
    3. Попытка запустить по имени: executable заканчивается ошибкой
    4. Запуск через точку происходит успешно

Изменение переменной PATH

В общем случае не рекомендуется делать это самостоятельно. При правильной установке, большинство программ самостоятельно добавляют свои исполняемые файлы в нужные места. В некоторых случаях они показывают подсказки, как это сделать сразу после установки.

Для ручного изменения переменной PATH нужно поправить один из конфигурационных файлов Bash. Эти файлы лежат в домашней директории пользователя:

    .bashrc
    .bash_profile
    .profile

В зависимости от настроек терминала, Bash прогружает либо одни файлы, либо другие. Если в вашей домашней директории есть файл .bashrc, то пробуйте использовать его, если нет, то остальные файлы в том порядке, в котором они приведены выше. Добавьте в этот файл следующую строку:

export PATH=$PATH:/path/to/directory

Где /path/to/directory путь до директории с исполняемыми файлами.

После этих манипуляций не забудьте перезапустить терминал.