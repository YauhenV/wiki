Основы командной строки


Установка WSL
Теперь вы можете установить все необходимое для запуска подсистемы Windows для Linux (WSL).
Ссылка: https://docs.microsoft.com/ru-ru/windows/wsl/install


Командная строка.
Для работы с командной строкой понадобятся две вещи:
1. Терминал.
2. Командный интерпретатор.
*
Терминал 
Терминалом называют программу, которая эмулирует поведение "железного" терминала, состоящего из клавиатуры и монитора
*
Командный интерпретатор
У этого понятия множество синонимов, среди них shell ("шелл"), командная оболочка и командный процессор. Командная оболочка — программа, через которую пользователь (или администратор) управляет операционной системой и установленными программами, используя командную строку. 
*
Символ $ используется как разделитель. Слева от него — настраиваемое сообщение для вывода, обычно текущая директория, а справа — то, что вводится пользователем.
*
# комментарии
*
Командные оболочки, как и терминалы, бывают разные, хотя по умолчанию в большинстве операционных систем стоит Bash.
Командная оболочка и терминал — не одно и то же. Терминал — это программа, которая запускает командную оболочку внутри себя.
*
Командную оболочку нередко называют реплом (REPL, Read-Eval-Print-Loop), что отражается в способе взаимодействия с пользователем:

    Read — шелл ждёт ввода команды от пользователя
    Eval — шелл исполняет введённую команду
    Print — шелл выводит результат
    Loop — возвращаемся к первому пункту
Этот процесс называется интерактивной сессией: после загрузки шелл ждёт ввода команды, затем он её исполняет, выводит результат и снова ждёт ввода команды. Так происходит до тех пор, пока не будет дана команда на выход из терминала или выключение компьютера. REPL — широко распространённый способ взаимодействия с пользователем. В следующих курсах вы увидите, что он есть и у баз данных, и у языков программирования.


Навигация
Можно сказать, что мы всегда находимся внутри какой-то директории, которую называют "рабочей", working directory. Проверяется текущая директория командой pwd.
*
 Возможно, вы знаете, что путь до файла может быть либо абсолютный, либо относительный. Абсолютный путь — это полный путь начиная от корня, в нашем случае /, а относительный — это путь, начинающийся от нашей текущей рабочей директории. Выше мы указали относительный путь. Отличить их друг от друга очень легко: если первым символом в пути идёт /, то это абсолютный путь, иначе — относительный.
Команда cd понимает и абсолютные и относительные пути.
*
Для перехода на директорию уровнем выше необходимо указать специальное значение .., и произойдёт переход на директорию уровнем выше. (cd .. или cd ../..).
Команда cd, выполненная без аргументов, перебрасывает в домашнюю директорию текущего пользователя.
Домашняя директория пользователя имеет специальное обозначение — ~ (тильда), которое в момент выполнения команды заменяется на абсолютный путь.


Интерфейс командной строки
Если в GUI (Graphical User Interface — графический интерфейс) можно взять любую незнакомую программу, запустить её, почитать названия пунктов меню, потыкать на разные кнопки и получить какой-нибудь результат, то в CLI (Command Line Interface — интерфейс командной строки) у вас нет ничего кроме названия программы и как ей пользоваться — непонятно.
*
Но что, если мы захотим посмотреть скрытые файлы и директории (в *nix-системах они начинаются с символа "точка", например .profile)? Тогда необходимо набрать ls -a
*
У команд бывают аргументы и опции (их также называют флагами). Например, в команде ls Music, Music — это аргумент, а вот в команде ls -a, -a — это опция.
   Опции всегда начинаются с одного или двух дефисов
Для просмотра полного содержимого директории Music с информацией о каждом файле достаточно набрать ls -la Music.
*
Опции указываются слева от аргументов, но иногда бывают ситуации, что они используются справа, такое чаще встречается в сложных утилитах со вложенными командами.
*
Достаточно набрать man <имя команды> — и мы попадём в режим чтения документации. В мануале содержится много полезной информации, например, описание утилиты в целом, формат её вызова, все возможные опции и даже примеры вызовов.
!!!!!!!!!!!!!!!!!!!
	Ещё полезен сайт https://explainshell.com/, в который достаточно вбить любую команду, и он покажет удобное интерактивное описание.
!!!!!!!!!!!!!!!!!!!
*
Большинство утилит имеет две версии одной и той же опции: одна из них длинная, другая — короткая. Например -v и --version в PHP.
*
$ say -o hi.aac 'Hello, World.'

Значение опции указывается через пробел от самой опции. Если значение опции содержит в себе специальные или пробельные символы, то его нужно оборачивать в кавычки, двойные или одинарные - не важно.

$ say -o 'hi.aac' 'Hello, World.'

Некоторые программы допускают использование знака = вместо пробела.

# Команда say такое не позволяет, но зато видно принцип
$ say -o=hi.aac 'Hello, World.'
*
Подобное описание есть практически у любой утилиты. Описания построены по одному и тому же принципу. Квадратные скобки [] обозначают необязательность. Например, опция -v необязательна, то же самое касается и любых других опций этой программы. Вертикальная черта | обозначает операцию "или", причём именно исключающее или. Посмотрите на последний блок [-f file | string ...]. Он означает, что say может либо произносить текст из файла, либо произносить строчку, переданную как аргумент, но не то и другое одновременно. Бывают и другие вариации описания способов вызова: значение по умолчанию, выбор из конкретных элементов, отрицание.



Файловая структура
Файловая структура *nix-систем серьёзно отличается от структуры в Windows и заслуживает отдельного внимания. Начнём с базовых понятий. Файловая структура представляет собой дерево, в узлах которого находятся директории (файлы специального типа), а в листьях — файлы.
*
Информация о любом файле или директории доступна по команде stat (file system status)
*
В Windows мы привыкли, что имя файла может быть набрано в разных регистрах, и это всегда один и тот же файл, то есть имена регистронезависимы. В *nix-системах регистр имеет значение. Файлы index.html, Index.html, INDEX.HTML и index.HTML — это разные файлы. Всегда обращайте внимание на регистр, потому что ошибиться довольно легко.
*
Говорят, что в *nix "всё есть файл". На нижнем уровне так и есть (почти). Директория — это специальный файл, который содержит список файлов. Любое подключаемое устройство становится файлом или директорией, если это накопитель.
*
В *nix-системах есть базовый набор каталогов, который стандартизирован (FHS). За каждым закреплена какая-то особая роль. Например, каталог /etc содержит конфигурацию программ в обычных текстовых файлах (в юниксах нет реестра, вся конфигурация лежит в обычных файлах), а каталог /home содержит домашние директории пользователей системы (исключением является суперпользователь root, его домашний каталог обычно находится по адресу /root). Обязательно пробегитесь по странице
!!!!!!!
https://ru.wikipedia.org/wiki/FHS
!!!!!
и посмотрите, что за что отвечает.
*
В отличие от Windows, в *nix-системах отсутствует понятие "расширение файла". Точка — полноправная часть имени. Это не значит, что в юниксах невозможно понять тип файла. Это возможно, более того, файлы почти всегда именуются так же, как и в Windows, например hello.mp3, но важно понимать, что вся эта строчка — имя файла. Нередко встречаются и такие имена: index.html.haml. В *nix также есть скрытые файлы, но, в отличие от Windows, это не свойство файла, а определённое имя файла. Все файлы и директории, начинающиеся с точки, считаются скрытыми. Вывести все файлы, включая скрытые, можно командой ls -a.
	Обратите внимание на две особые директории, обозначенные "точкой" (.) и "двумя точками" (..). Точка означает текущую директорию, а две точки — директорию верхнего уровня. Именно благодаря этой схеме работает команда cd .., которая перемещает нас на уровень выше.
*
Кроме обычных файлов, в *nix существует ряд других:

    Hard Link — дополнительное имя для уже существующего файла.
    Symbolic link — символическая ссылка, такой файл похож на ярлык в Windows. Если удалить основной файл, то символическая ссылка начнёт вести в никуда.
    Socket — специальный файл, через который происходит взаимодействие между разными процессами операционной системы. Программисты постоянно сталкиваются с сокетами в реальной жизни.



Чтение файлов
Самый простой способ прочитать файл — команда cat.
cat ожидает аргументы — пути до файлов, которые надо читать. В простейшем случае достаточно передать один путь, это довольно удобно, когда надо посмотреть содержимое небольшого файла.
*
Иногда нужно посмотреть только начало файла или его конец, в такой ситуации помогают команды head и tail. Они тоже принимают на вход путь до файла, только head показывает первые 10 строк, а tail — последние 10 строк файла. Это поведение можно менять, задавая желаемое количество строк через опцию -n.
$ head -n 2 .bashrc
$ tail -n 2 .bashrc
*
Некоторые файлы наполняются очень интенсивно. Например, так называемые "логи". Логи (иногда говорят "журналы") — это текстовые файлы, в которые заносится информация о происходящих процессах в определённой системе. В Linux логи лежат в каталоге /var/log. Туда пишет как сам Linux, так и большая часть установленных программ. Основной файл логов Linux называется syslog. Туда попадает ключевая информация о происходящих процессах в операционной системе и возникающих ошибках. Если события происходят часто и есть потребность анализировать их в процессе поступления, то команда cat оказывается неудобной, потому что syslog большой. Не подходит и простой запуск команды tail, потому что придётся запускать её каждую секунду и всё равно можно что-нибудь пропустить (если интенсивность записи событий в лог очень высокая).

В этой ситуации поможет tail, запущенный в особом режиме благодаря флагу -f. Команда tail -f path/to/file не просто выводит последние строчки файла, но ждёт появления новых. Как только файл дописывается, tail сразу выводит на экран добавленные строки. Среди наших примеров это первая команда, которая захватывает управление, то есть после запуска она не заканчивает выполнение сразу, а продолжает работать, ожидая новые данные в файле, который выводится. Для остановки её выполнения нажмите Ctrl + C.
*
Особая категория программ для просмотра содержимого файла — пейджеры. Пейджер похож на текстовый редактор, но открытый только в режиме чтения. Самый распространённый пейджер называется less. Попробуем открыть с помощью него файл syslog:
$ sudo less syslog
less открывает файл и остаётся в этом режиме. Он позволяет перемещаться по файлу вперёд и назад, производить поиск. Одна из отличительных особенностей пейджеров состоит в том, что они одинаково хорошо и быстро работают с файлами любых размеров. Всё потому, что пейджер не пытается загрузить в память весь файл до его отображения. Он грузит только ту часть, которая помещается на экран и при перемещении подгружает остальное.

less предоставляет несколько десятков команд для перемещения по тексту и его поиску, про большинство из них можно прочитать в соответствующем мануале. Здесь же затронем основные:

    q — выход
    f — вперёд на страницу
    b — назад на страницу
    если набрать /, затем начать вводить буквы и нажать Enter, то выполнится поиск введённого текста. Перемещение по найденным совпадениям выполняется командой n (переход к следующему совпадению) и командой N (переход к предыдущему совпадению).

Возможно, вы увидели сходство поведения пейджеров с тем, что мы наблюдали в мануалах. Открою секрет: когда мы запускали man, то перед нами открывался less с загруженным туда контентом. Как вы увидите позже, пейджеры невероятно популярны и неявно запускаются другими программами.



Grep
Наименование происходит от консольной утилиты grep (global regular expression print), выполняющей поиск по файлу или файлам определённого текста.
$ man grep

SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]

PATTERN — это то, что ищется, необязательно конкретная строчка, возможно определённый шаблон (см. регулярные выражения). FILE — путь до файла, в котором нужно искать
*
Найденные строчки выводятся на экран в том же порядке, в котором они встречаются в исходном файле. В некоторых ситуациях бывает важно увидеть не только саму строку, содержащую подстроку, но и то, что находится вокруг неё. Количество выводимых соседних строк регулируется опциями -B, -A и -C. Первая определяет количество отображаемых строк до искомой (-B, --before-context), вторая — после (-A, --after-context), а третья — до и после одновременно (-C, --context). Ниже пример использования -C со значением 1. Это значит, что для каждой найденной строки будет выведена одна строка выше и одна строка ниже.



Редактирование файлов
Для редактирования файлов в командной строке используют редакторы Nano, Vim и Emacs. В большинстве случаев в системе установлен только Vim, поэтому крайне важно владеть базовыми навыками обращения с ним. Эти редакторы запускаются прямо в терминале, хотя Vim и Emacs имеют режим, в котором они запускаются как отдельные приложения.


Nano

Nano очень простенький текстовый редактор, похожий на "блокнот" в Windows, хотя по возможностям он богаче и даже способен подсвечивать содержимое файлов.

$ nano .bashrc

После запуска редактора внизу открывается панель с подсказками, какие горячие клавиши доступны для использования. Символ ^ означает клавишу Ctrl. Например, для выхода из редактора нужно набрать Ctrl + x, а затем либо подтвердить сохранение изменений, либо отвергнуть, нажав y (yes) или n (no). В принципе, больше ничего интересного про nano сказать нельзя. Редактор и редактор. Подходит для несложных изменений в файлах, но совсем неудобен для работы над многофайловыми проектами, да ещё и с кодом.


Vim

Совсем другое дело Vim (Vi Improved или улучшенный vi) — свободный текстовый редактор, созданный на основе более старого vi (visual editor). Это редактор-комбайн, который, к тому же, имеет абсолютно непохожую ни на что другое модель работы.

$ vim .bashrc

Ключевое отличие (а их много!) вима от остальных редакторов — в наличии режимов. В обычных редакторах, после того как открылся файл, можно сразу приступать к редактированию. Вим после открытия работает в режиме команд (COMMAND): нажатие на любую клавишу воспринимается как сигнал к какому-то действию. Если вы не знаете команд, то лучше ничего не трогать, иначе на экране начнётся хаос. Обычное редактирование текста выполняется в режиме ввода (INSERT) и попасть в него можно нажав клавишу i. Для выхода в режим команд достаточно нажать Esc (или комбинацию Ctrl + [).

 С другой стороны, чем дальше вы будете продвигаться по стезе программиста, тем больше вы начнёте замечать, что опытные и многие известные программисты предпочитают разрабатывать целиком и полностью в виме. Посмотрев на вим без плагинов, сложно в это поверить, но он становится очень навороченным благодаря расширениям. Подробнее о том, почему так происходит и что особенного в виме, написано в нашем руководстве. Крайне рекомендую к прочтению. (https://guides.hexlet.io/vim/)

Говорят, что самое сложное в виме — это выйти, поэтому подготовимся заранее. Убедитесь, что вы находитесь в командном режиме, на всякий случай нажмите Esc (или комбинацию Ctrl + [). Затем наберите :, эта команда переведёт вас в режим командной строки (ещё один режим), затем введите q! и нажмите Enter. Так вы выйдете из вима без сохранения изменений. Если набрать :wq, то перед выходом сохранятся все изменения. Если вы хотите просто сохраниться без выхода, то наберите :w.

В Vim есть четыре основных режима работы:

    Командный режим (обычный режим) — это режим по умолчанию. Перемещение по файлу, быстрое (при помощи команд, комбинаций клавиш) редактирование, удаление, поиск текста.
    Режим вставки (режим ввод) — ввод текста с клавиатуры. То, как вы привыкли это делать в обычных редакторах.
    Визуальный режим — выделение произвольных участков текста.
    Режим командной строки — собственная командная строка для редактора текста, из которой можно выполнять великое множество разнообразных команд.

Кстати, большая часть Хекслета как платформы и почти весь текстовый контент (курсы) сделаны именно в виме. Включая эту строчку ;)
