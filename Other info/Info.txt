============================================
Фреймы и окна
============================================
Открытие окон и методы window

Всплывающие окна используются нечасто. Ведь загрузить новую информацию можно динамически, а показать – в элементе <div>, расположенным над страницей (z-index). Ещё одна альтернатива – тег <iframe>.

Если мы открываем попап, хорошей практикой будет предупредить пользователя об этом. Иконка открывающегося окошка на ссылке поможет посетителю понять, что происходит и не потерять оба окна из поля зрения.

- Новое окно можно открыть с помощью вызова open(url, name, params). Этот метод возвращает ссылку на это новое окно.
- По умолчанию браузеры блокируют вызовы open, выполненные не в результате действий пользователя. Обычно браузеры показывают предупреждение, так что пользователь всё-таки может разрешить вызов этого метода.
- Вместо попапа открывается вкладка, если в вызове open не указаны его размеры.
- У попапа есть доступ к породившему его окну через свойство window.opener.
- Если основное окно и попап имеют один домен и протокол, то они свободно могут читать и изменять друг друга. В противном случае, они могут только изменять положение друг друга и взаимодействовать с помощью сообщений.

Чтобы закрыть попап: метод close(). Также попап может закрыть и пользователь (как и любое другое окно). После закрытия окна свойство window.closed имеет значение true.

- Методы focus() и blur() позволяют установить или убрать фокус с попапа. Но работают не всегда.
- События focus и blur позволяют отследить получение и потерю фокуса новым окном. Но, пожалуйста, не забывайте, что окно может остаться видимым и после blur.
==========================================================================


==========================================================================
Политика "Одинакового источника"

Чтобы вызвать метод или получить содержимое из другого окна, нам, во-первых, необходимо иметь ссылку на него.

Для всплывающих окон (попапов) доступны ссылки в обе стороны:

- При открытии окна: window.open открывает новое окно и возвращает ссылку на него,
- Изнутри открытого окна: window.opener – ссылка на открывающее окно.

Для ифреймов мы можем иметь доступ к родителям/потомкам, используя:

- window.frames – коллекция объектов window вложенных ифреймов,
- window.parent, window.top – это ссылки на родительское окно и окно самого верхнего уровня,
- iframe.contentWindow – это объект window внутри тега <iframe>.

Если окна имеют одинаковый источник (протокол, домен, порт), то они могут делать друг с другом всё, что угодно.

В противном случае возможны только следующие действия:

- Изменение свойства location другого окна (доступ только на запись).
- Отправить туда сообщение.

Исключения:

- Окна, которые имеют общий домен второго уровня: a.site.com и b.site.com. Установка свойства document.domain='site.com' в обоих окнах переведёт их в состояние «Одинакового источника».
- Если у ифрейма установлен атрибут sandbox, это принудительно переведёт окна в состояние «разных источников», если не установить в атрибут значение allow-same-origin. Это можно использовать для запуска ненадёжного кода в ифрейме с того же сайта.

Метод postMessage позволяет общаться двум окнам с любыми источниками:

1. Отправитель вызывает targetWin.postMessage(data, targetOrigin).
2. Если targetOrigin не '*', тогда браузер проверяет имеет ли targetWin источник targetOrigin.
3.Если это так, тогда targetWin вызывает событие message со специальными свойствами:
- origin – источник окна отправителя (например, http://my.site.com)
- source – ссылка на окно отправитель.
- data – данные, может быть объектом везде, кроме IE (в IE только строки).

В окне-получателе следует добавить обработчик для этого события с помощью метода addEventListener.
========================


========================
Атака типа clickjacking

Атака сlickjacking – это способ хитростью «заставить» пользователей кликнуть на сайте-жертве, без понимания, что происходит. Она опасна, если по клику могут быть произведены важные действия.

Хакер может разместить ссылку на свою вредоносную страницу в сообщении или найти другие способы, как заманить пользователей. Вариантов множество.

С одной стороны — эта атака «неглубокая», ведь хакер перехватывает только один клик. Но с другой стороны, если хакер знает, что после этого клика появятся другие элементы управления, то он может хитростью заставить пользователя кликнуть на них.

Этот вид атаки довольно опасен, ведь при разработке интерфейсов мы не предполагаем, что хакер может кликнуть от имени пользователя. Поэтому уязвимости могут быть обнаружены в совершенно неожиданных местах.

Для защиты от этой атаки рекомендуется использовать X-Frame-Options: SAMEORIGIN на страницах или даже целиком сайтах, которые не предназначены для просмотра во фрейме.
Или, если мы хотим разрешить отображение страницы во фрейме и при этом оставаться в безопасности, то можно использовать перекрывающий блок <div>.
=================================================================

=================================================================
Бинарные данные и файлы
=================================================================
ArrayBuffer, бинарные массивы

ArrayBuffer – это корневой объект, ссылка на непрерывную область памяти фиксированной длины.

Чтобы работать с объектами типа ArrayBuffer, нам нужно представление («view»).

- Это может быть типизированный массивTypedArray:
	- Uint8Array, Uint16Array, Uint32Array – для беззнаковых целых по 8, 16 и 32 бита 	соответственно.
	- Uint8ClampedArray – для 8-битных беззнаковых целых, которые обрезаются по верхней и 	нижней границе при присвоении.
	- Int8Array, Int16Array, Int32Array – для знаковых целых чисел (могут быть 			отрицательными).
	Float32Array, Float64Array – для 32- и 64-битных знаковых чисел с плавающей точкой.
- Или DataView – представление, использующее отдельные методы, чтобы уточнить формат данных при обращении, например, getUint8(offset).

Обычно мы создаём и работаем с типизированными массивами, оставляя ArrayBuffer «под капотом». Но мы можем в любой момент получить к нему доступ с помощью .buffer и при необходимости создать другое представление.

Существуют ещё 2 дополнительных термина, которые используются в описаниях методов, работающих с бинарными данными:

- ArrayBufferView – это общее название для представлений всех типов.
- BufferSource – это общее название для ArrayBuffer или ArrayBufferView.

Мы встретимся с ними в следующих главах. BufferSource встречается очень часто и означает «бинарные данные в любом виде» – ArrayBuffer или его представление.
========================================================================


========================================================================
TextDecoder и TextEncoder

TextDecoder

Что если бинарные данные фактически являются строкой? Например, мы получили файл с текстовыми данными.

Встроенный объект TextDecoder позволяет декодировать данные из бинарного буфера в обычную строку.

Для этого прежде всего нам нужно создать сам декодер:

let decoder = new TextDecoder([label], [options]);

- label – тип кодировки, utf-8 используется по умолчанию, но также поддерживаются big5, windows-1251 и многие другие.
- options – объект с дополнительными настройками:
	- fatal – boolean, если значение true, тогда генерируется ошибка для невалидных (не 		декодируемых) символов, в ином случае (по умолчанию) они заменяются символом \uFFFD.
	- ignoreBOM – boolean, если значение true, тогда игнорируется BOM (дополнительный 		признак, определяющий порядок следования байтов), что необходимо крайне редко.

…и после использовать его метод decode:

let str = decoder.decode([input], [options]);

- input – бинарный буфер (BufferSource) для декодирования.
- options – объект с дополнительными настройками:
	- stream – true для декодирования потока данных, при этом decoder вызывается вновь и 	вновь для каждого следующего фрагмента данных. В этом случае многобайтовый символ 	может иногда быть разделён и попасть в разные фрагменты данных. Это опция указывает 	TextDecoder запомнить символ, на котором остановился процесс, и декодировать его со 	следующим фрагментом.


TextEncoder

TextEncoder поступает наоборот – кодирует строку в бинарный массив.

Имеет следующий синтаксис:

let encoder = new TextEncoder();

Поддерживается только кодировка «utf-8».

Кодировщик имеет следующие два метода:

- encode(str) – возвращает бинарный массив Uint8Array, содержащий закодированную строку.
- encodeInto(str, destination) – кодирует строку (str) и помещает её в destination, который должен быть экземпляром Uint8Array.
========================================


========================================
Blob

В то время как ArrayBuffer, Uint8Array и другие BufferSource являются «бинарными данными», Blob представляет собой «бинарные данные с типом».

Это делает Blob удобным для операций загрузки/выгрузки данных, которые так часто используются в браузере.

Методы, которые выполняют сетевые запросы, такие как XMLHttpRequest, fetch и подобные, могут изначально работать с Blob так же, как и с другими объектами, представляющими двоичные данные.

Мы можем легко конвертировать Blob в низкоуровневые бинарные типы данных и обратно:

- Мы можем создать Blob из типизированного массива, используя конструктор new Blob(...).
- Мы можем обратно создать ArrayBuffer из Blob, используя FileReader, а затем создать его представление для низкоуровневых операций.
================================================


================================================
File и FileReader

File объекты наследуют от Blob.

Помимо методов и свойств Blob, объекты File также имеют свойства name и lastModified плюс внутреннюю возможность чтения из файловой системы. Обычно мы получаем объекты File из пользовательского ввода, например, через <input> или перетаскиванием с помощью мыши, в событии dragend.

Объекты FileReader могут читать из файла или Blob в одном из трёх форматов:

- Строка (readAsText).
- ArrayBuffer (readAsArrayBuffer).
- URL в формате base64 (readAsDataURL).

Однако, во многих случаях нам не нужно читать содержимое файла. Как и в случае с Blob, мы можем создать короткий URL с помощью URL.createObjectURL(file) и использовать его в теге <a> или <img>. Таким образом, файл может быть загружен или показан в виде изображения, как часть canvas и т.д.

А если мы собираемся отправить File по сети, то это также легко, поскольку в сетевые методы, такие как XMLHttpRequest или fetch, встроена возможность отсылки File.
========================================================================


========================================================================
Сетевые запросы
========================================================================
Fetch

Типичный запрос с помощью fetch состоит из двух операторов await:

let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON

Или, без await:

fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)

Параметры ответа:

response.status – HTTP-код ответа,
response.ok – true, если статус ответа в диапазоне 200-299.
response.headers – похожий на Map объект с HTTP-заголовками.

Методы для получения тела ответа:

response.text() – возвращает ответ как обычный текст,
response.json() – преобразовывает ответ в JSON-объект,
response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
response.blob() – возвращает объект как Blob (бинарные данные с типом),
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),

Опции fetch, которые мы изучили на данный момент:

method – HTTP-метод,
headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.
============================


============================
FormData

Объекты FormData используются, чтобы взять данные из HTML-формы и отправить их с помощью fetch или другого метода для работы с сетью.

Мы можем создать такой объект уже с данными, передав в конструктор HTML-форму – new FormData(form), или же можно создать объект вообще без формы и затем добавить к нему поля с помощью методов:

formData.append(name, value)
formData.append(name, blob, fileName)
formData.set(name, value)
formData.set(name, blob, fileName)

Отметим две особенности:

1) Метод set удаляет предыдущие поля с таким же именем, а append – нет. В этом их единственное отличие.
2) Чтобы послать файл, нужно использовать синтаксис с тремя аргументами, в качестве третьего как раз указывается имя файла, которое обычно, при <input type="file">, берётся из файловой системы.

Другие методы:

formData.delete(name)
formData.get(name)
formData.has(name)
========================


========================
Fetch: ход загрузки

Метод fetch позволяет отслеживать процесс получения данных.

Чтобы отслеживать ход загрузки данных с сервера, можно использовать свойство response.body. Это ReadableStream («поток для чтения») – особый объект, который предоставляет тело ответа по частям, по мере поступления. Потоки для чтения описаны в спецификации Streams API.

В отличие от response.text(), response.json() и других методов, response.body даёт полный контроль над процессом чтения, и мы можем подсчитать, сколько данных получено на каждый момент.

Чтобы отслеживать процесс загрузки, нам нужно при получении очередного фрагмента прибавлять его длину value к счётчику.
=============================


=============================
Fetch: прерывание запроса

Как мы знаем, метод fetch возвращает промис. А в JavaScript в целом нет понятия «отмены» промиса. Как же прервать запрос fetch?

Для таких целей существует специальный встроенный объект: AbortController, который можно использовать для отмены не только fetch, но и других асинхронных задач.

Использовать его достаточно просто:

1) Шаг 1: создаём контроллер:

let controller = new AbortController();

Контроллер controller – чрезвычайно простой объект.

	- Он имеет единственный метод abort() и единственное свойство signal.
	- При вызове abort():
		- генерируется событие с именем abort на объекте controller.signal
		- свойство controller.signal.aborted становится равным true.

Все, кто хочет узнать о вызове abort(), ставят обработчики на controller.signal, чтобы отслеживать его.

Вот так (пока без fetch):

let controller = new AbortController();
let signal = controller.signal;

// срабатывает при вызове controller.abort()
signal.addEventListener('abort', () => alert("отмена!"));

controller.abort(); // отмена!

alert(signal.aborted); // true

2) Шаг 2: передайте свойство signal опцией в метод fetch:

let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});

Метод fetch умеет работать с AbortController, он слушает событие abort на signal.

3) Шаг 3: чтобы прервать выполнение fetch, вызовите controller.abort():

controller.abort();

Вот и всё: fetch получает событие из signal и прерывает запрос.

Когда fetch отменяется, его промис завершается с ошибкой AbortError, поэтому мы должны обработать её, например, в try..catch
========================================


========================================
Fetch: запросы на другие сайты

С точки зрения браузера запросы к другому источнику бывают двух видов: «простые» и все остальные.

Простые запросы должны удовлетворять следующим условиям:

- Метод: GET, POST или HEAD.
- Заголовки – мы можем установить только:
	- Accept
	- Accept-Language
	- Content-Language
	- Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или 	text/plain.

Основное их отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов <form> или <script>, в то время как непростые долгое время были невозможны для браузеров.

Практическая разница состоит в том, что простые запросы отправляются сразу с заголовком Origin, а для других браузер делает предварительный запрос, спрашивая разрешения.

Для простых запросов:

→ Браузер посылает заголовок Origin с источником.
← Для запросов без авторизационных данных (не отправляются по умолчанию) сервер должен установить:
	- Access-Control-Allow-Origin в * или то же значение, что и Origin
← Для запросов с авторизационными данными сервер должен установить:
	- Access-Control-Allow-Origin в то же значение, что и Origin
	- Access-Control-Allow-Credentials в true

Дополнительно, чтобы разрешить JavaScript доступ к любым заголовкам ответа, кроме Cache-Control, Content-Language, Content-Type, Expires, Last-Modified или Pragma, сервер должен перечислить разрешённые в заголовке Access-Control-Expose-Headers.

Для непростых запросов перед основным запросом отправляется предзапрос:

→ Браузер посылает запрос OPTIONS на тот же адрес с заголовками:
	- Access-Control-Request-Method – содержит запрашиваемый метод,
	- Access-Control-Request-Headers – перечисляет непростые запрашиваемые заголовки.
← Сервер должен ответить со статусом 200 и заголовками:
	- Access-Control-Allow-Methods со списком разрешённых методов,
	- Access-Control-Allow-Headers со списком разрешённых заголовков,
	- Access-Control-Max-Age с количеством секунд для кеширования разрешений
→ Затем отправляется основной запрос, применяется предыдущая «простая» схема.
================================================================================


================================================================================
XMLHttpRequest

Типичный код GET-запроса с использованием XMLHttpRequest:

let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP ошибка?
    // обработаем ошибку
    alert( 'Ошибка: ' + xhr.status);
    return;
  }

  // получим ответ из xhr.response
};

xhr.onprogress = function(event) {
  // выведем прогресс
  alert(`Загружено ${event.loaded} из ${event.total}`);
};

xhr.onerror = function() {
  // обработаем ошибку, не связанную с HTTP (например, нет соединения)
};

Событий на самом деле больше, в современной спецификации они все перечислены в том порядке, в каком генерируются во время запроса:

loadstart – начало запроса.
progress – прибыла часть данных ответа, тело ответа полностью на данный момент можно получить из свойства responseText.
abort – запрос был прерван вызовом xhr.abort().
error – произошла ошибка соединения, например неправильное доменное имя. Событие не генерируется для HTTP-ошибок как, например, 404.
load – запрос успешно завершён.
timeout – запрос был отменён по причине истечения отведённого для него времени (происходит, только если был установлен таймаут).
loadend – срабатывает после load, error, timeout или abort.

События error, abort, timeout и load взаимно исключают друг друга – может произойти только одно из них.

Наиболее часто используют события завершения загрузки (load), ошибки загрузки (error), или мы можем использовать единый обработчик loadend для всего и смотреть в свойствах объекта запроса xhr детали произошедшего.

Также мы уже видели событие: readystatechange. Исторически оно появилось одним из первых, даже раньше, чем была составлена спецификация. Сегодня нет необходимости использовать его, так как оно может быть заменено современными событиями, но на него можно часто наткнуться в старом коде.

Если же нам нужно следить именно за процессом отправки данных на сервер, тогда можно использовать те же события, но для объекта xhr.upload.
=======================================================


=======================================================
WebSocket

WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.

- Нет ограничений, связанных с кросс-доменными запросами.
- Имеют хорошую поддержку браузерами.
- Могут отправлять/получать как строки, так и бинарные данные.

API прост.

Методы:

socket.send(data),
socket.close([code], [reason]).

События:

open,
message,
error,
close.

WebSocket сам по себе не содержит такие функции, как переподключение при обрыве соединения, аутентификацию пользователей и другие механизмы высокого уровня. Для этого есть клиентские и серверные библиотеки, а также можно реализовать это вручную.

Иногда, чтобы добавить WebSocket к уже существующему проекту, WebSocket-сервер запускают параллельно с основным сервером. Они совместно использует одну базу данных. Запросы к WebSocket отправляются на wss://ws.site.com – поддомен, который ведёт к WebSocket-серверу, в то время как https://site.com ведёт на основной HTTP-сервер.

Конечно, возможны и другие пути интеграции.
============================================


============================================
Server Sent Events

Объект EventSource автоматически устанавливает постоянное соединение и позволяет серверу отправлять через него сообщения.

Он предоставляет:

- Автоматическое переподключение с настраиваемой retry задержкой.
- Идентификаторы сообщений для восстановления соединения. Последний полученный идентификатор посылается в заголовке Last-Event-ID при пересоединении.
- Текущее состояние, записанное в свойстве readyState.

Это делает EventSource достойной альтернативой протоколу WebSocket, который сравнительно низкоуровневый и не имеет таких встроенных возможностей (хотя их и можно реализовать).

Для многих приложений возможностей EventSource вполне достаточно.

Поддерживается во всех современных браузерах (кроме Internet Explorer).

Синтаксис:

let source = new EventSource(url, [credentials]);

Второй аргумент – необязательный объект с одним свойством: { withCredentials: true }. Он позволяет отправлять авторизационные данные на другие домены.

В целом, кросс-доменная безопасность реализована так же как в fetch и других методах работы с сетью.


Свойства объекта EventSource

readyState
Текущее состояние подключения: EventSource.CONNECTING (=0), EventSource.OPEN (=1) или EventSource.CLOSED (=2).

lastEventId
id последнего полученного сообщения. При переподключении браузер посылает его в заголовке Last-Event-ID.


Методы

close()
Закрывает соединение.


События

message
Сообщение получено, переданные данные записаны в event.data.

open
Соединение установлено.

error
В случае ошибки, включая как потерю соединения, так и другие ошибки в нём. Мы можем обратиться к свойству readyState, чтобы проверить, происходит ли переподключение.

Сервер может выставить собственное событие с помощью event:. Такие события должны быть обработаны с помощью addEventListener, а не on<event>.


Формат ответа сервера

Сервер посылает сообщения, разделённые двойным переносом строки \n\n.

Сообщение состоит из следующих полей:

data: – тело сообщения, несколько data подряд интерпретируются как одно сообщение, разделённое переносами строк \n.
id: – обновляет свойство lastEventId, отправляемое в Last-Event-ID при переподключении.
retry: – рекомендованная задержка перед переподключением в миллисекундах. Не может быть установлена с помощью JavaScript.
event: – имя пользовательского события, должно быть указано перед data:.

Сообщение может включать одно или несколько этих полей в любом порядке, но id обычно ставят в конце.
============================


============================
Хранение данных в браузере
============================
Куки, document.cookie

document.cookie предоставляет доступ к куки.

- Операция записи изменяет только то куки, которое было указано.
- Имя и значение куки должны быть закодированы.
- Одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).

Настройки куки:

- path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
- domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
- expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
- secure делает куки доступным только при использовании HTTPS.
- samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.

Дополнительно:

- Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
- Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.
=======================================


=======================================
LocalStorage, sessionStorage

Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.

- key и value должны быть строками.
- Лимит 2 Мб+, зависит от браузера.
- Данные не имеют «времени истечения».
- Данные привязаны к источнику (домен/протокол/порт).

localStorage												sessionStorage
Совместно используется между всеми вкладками и окнами с одинаковым источником			Разделяется в рамках вкладки браузера, среди ифреймов из того же источника
«Переживает» перезапуск браузера								«Переживает» перезагрузку страницы (но не закрытие вкладки)

API:

setItem(key, value) – сохранить пару ключ/значение.
getItem(key) – получить данные по ключу key.
removeItem(key) – удалить значение по ключу key.
clear() – удалить всё.
key(index) – получить ключ на заданной позиции.
length – количество элементов в хранилище.
Используйте Object.keys для получения всех ключей.
Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событие storage не срабатывает.

Событие storage:

- Срабатывает при вызове setItem, removeItem, clear.
- Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.
- Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).
=====================================================================================


=====================================================================================
IndexedDB

IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.

Лучшим руководством является спецификация, текущая версия 2.0, но также поддерживаются несколько методов из 3.0 (не так много отличий) версии.

Использование можно описать в нескольких фразах:

1. Подключить обёртку над промисами, например idb.
2. Открыть базу данных: idb.openDb(name, version, onupgradeneeded)
	- Создайте хранилища объектов и индексы в обработчике onupgradeneeded или выполните 	обновление версии, если это необходимо
3. Для запросов:
	- Создать транзакцию db.transaction('books') (можно указать readwrite, если надо).
	- Получить хранилище объектов transaction.objectStore('books').
4. Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.
	- Для поиска по любому полю объекта создайте индекс.
5. Если данные не помещаются в памяти, то используйте курсор.
===============================================================


===============================================================
Анимация
===============================================================
Кривые Безье

Кривые Безье задаются опорными точками.

Мы рассмотрели два определения кривых:

1.Через математическую формулу.
2. Использование процесса рисования: алгоритм де Кастельжо.

Их удобство в том, что:

- Можно рисовать плавные линии с помощью мыши, перемещая контрольные точки.
- Сложные формы могут быть сделаны из нескольких кривых Безье.

Применение:

- В компьютерной графике, моделировании, в графических редакторах. Шрифты описываются с помощью кривых Безье.
- В веб-разработке – для графики на Canvas или в формате SVG. Кстати, все живые примеры выше написаны на SVG. Фактически, это один SVG-документ, к которому точки передаются параметрами. Вы можете открыть его в отдельном окне и посмотреть исходник: demo.svg.
- В CSS-анимации для задания траектории или скорости передвижения.
=====================================================================


=====================================================================
CSS-анимации

CSS-анимации позволяют плавно, или не очень, менять одно или несколько свойств.

Они хорошо решают большинство задач по анимации. Также мы можем реализовать анимации через JavaScript, более подробно об этом – в следующей главе.

Ограничения CSS-анимаций в сравнении с JavaScript-анимациями:

Достоинства:
- Простые анимации делаются просто.
- Быстрые и не создают нагрузку на CPU.

Недостатки:
- JavaScript-анимации более гибкие. В них может присутствовать любая анимационная логика, как например «взорвать» элемент.
- Можно изменять не только свойства. Мы можем создавать новые элементы с помощью JavaScript для анимации

Большинство анимаций может быть реализовано с использованием CSS, как описано в этой главе. А событие transitionend позволяет запускать JavaScript после анимации, поэтому CSS-анимации прекрасно интегрируются с кодом.
========================================


========================================
JavaScript-анимации

JavaScript может помочь в тех случаях, когда CSS не справляется или нужен жёсткий контроль над анимацией. JavaScript-анимации должны быть сделаны с помощью requestAnimationFrame. Это встроенный метод браузера, который вызывает переданную в него функцию в тот момент, когда браузер готовится совершить перерисовку (обычно это происходит быстро, но конкретные задержки зависят от браузера).

Когда вкладка скрыта, на ней совсем не происходит перерисовок, и функция не будет вызвана: анимация будет приостановлена и не потратит ресурсы. Это хорошо.

Вспомогательная функция animate для создания анимации:

function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction изменяется от 0 до 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // вычисление текущего состояния анимации
    let progress = timing(timeFraction);

    draw(progress); // отрисовать её

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}

Опции:

duration – общая продолжительность анимации в миллисекундах.
timing – функция вычисления прогресса анимации. Получается момент времени от 0 до 1, возвращает прогресс анимации, обычно тоже от 0 до 1.
draw – функция отрисовки анимации.

Конечно, мы могли бы улучшить вспомогательную функцию и добавить в неё больше наворотов. Но JavaScript-анимации не каждый день используются, а только когда хотят сделать что-то интересное и необычное. Не стоит усложнять функцию до тех пор пока это вам не понадобились.

JavaScript-анимации могут использовать любые функции расчёта времени. Мы рассмотрели множество примеров и их вариаций, чтобы сделать их ещё более универсальными. В отличие от CSS, мы здесь не ограничены только кривой Безье.

То же самое и с draw: мы можем анимировать всё что угодно, не только CSS-свойства.
======================================================================================


======================================================================================
Веб-компоненты
======================================================================================
Пользовательские элементы (Custom Elements)

Есть два типа пользовательских элементов:

1. «Автономные» – новые теги, расширяющие HTMLElement.

Схема определения:

class MyElement extends HTMLElement {
  constructor() { super(); /* ... */ }
  connectedCallback() { /* ... */ }
  disconnectedCallback() { /* ... */  }
  static get observedAttributes() { return [/* ... */]; }
  attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
  adoptedCallback() { /* ... */ }
 }
customElements.define('my-element', MyElement);
/* <my-element> */


2. «Модифицированные встроенные элементы» – расширения существующих элементов.

Требуют ещё один аргумент в .define и атрибут is="..." в HTML:

class MyButton extends HTMLButtonElement { /*...*/ }
customElements.define('my-button', MyElement, {extends: 'button'});
/* <button is="my-button"> */

Пользовательские элементы широко поддерживаются браузерами. Edge немного отстаёт, но есть полифил https://github.com/webcomponents/webcomponentsjs.
===========================================================


===========================================================
Shadow DOM

Теневой DOM – это способ создать свой, изолированный, DOM для компонента.

- shadowRoot = elem.attachShadow({mode: open|closed}) – создаёт теневой DOM для elem. Если mode="open", он доступен через свойство elem.shadowRoot.
- Мы можем создать подэлементы внутри shadowRoot с помощью innerHTML или других методов DOM.

Элементы теневого DOM:

- Обладают собственной областью видимости идентификаторов
- Невидимы JavaScript селекторам из главного документа, таким как querySelector,
- Стилизуются своими стилями из теневого дерева, не из главного документа.

Теневой DOM, если имеется, отрисовывается браузером вместо обычных потомков (light DOM). В главе Слоты теневого DOM, композиция мы разберём, как делать их композицию.
==============================================================================


==============================================================================
Элемент "template"

Подводим итоги:

- Содержимым <template> может быть любой синтаксически корректный HTML.
- Содержимое <template> считается находящимся «вне документа», поэтому оно ни на что не влияет.
- Мы можем получить доступ к template.content из JavaScript, клонировать его и переиспользовать в новом компоненте.

Элемент <template> уникальный по следующим причинам:

- Браузер проверяет правильность HTML-синтаксиса в нём (в отличие от строк в скриптах).
- …При этом позволяет использовать любые HTML-теги, даже те, которые без соответствующей обёртки не используются (например <tr>).
- Его содержимое оживает (скрипты выполняются, <video autoplay> проигрывается и т. д.), когда помещается в документ.

Элемент <template> не поддерживает итерацию, связывания данных или подстановки переменных. Однако эти возможности можно реализовать поверх него.
========================================================


========================================================
Слоты теневого DOM, композиция

Обычно, если у элемента есть теневое дерево, то содержимое обычного, светлого DOM не показывается. Слоты позволяют показать элементы светлого DOM на заданных местах в теневом DOM.

Существует два вида слотов:

- Именованные слоты: <slot name="X">...</slot> – получают элементы светлого DOM с slot="X".
- Слот по умолчанию: первый <slot> без имени (последующие неименованные слоты игнорируются) – показывает элементы элементов светлого дерева, которые не находятся в других слотах.
- Если одному слоту назначено несколько элементов, они добавляются один за другим.
- Содержимое элемента <slot> используется как резервное. Оно отображается, если в слоте нет элементов из светлого дерева.

Процесс отображения элементов внутри слота называется «композицией». В результате композиции строится «развёрнутый DOM».

При композиции не происходит перемещения узлов – с точки зрения JavaScript, DOM остаётся прежним.

JavaScript может получить доступ к слотам с помощью следующих методов:

- slot.assignedNodes/Elements() – возвращает узлы/элементы, которые находятся внутри slot.
- node.assignedSlot – обратный метод, возвращает слот по узлу.

Если мы хотим знать, что показываем, мы можем отследить контент слота следующими способами:

- событие slotchange – запускается, когда слот наполняется контентом в первый раз, и при каждой операции добавления/удаления/замещения элемента в слоте, за исключением его потомков. Сам слот будет event.target.
- MutationObserver для более глубокого просмотра содержимого элемента в слоте и отслеживания изменений в нём.

Теперь, когда мы научились показывать элементы светлого DOM в теневом DOM, давайте посмотрим, как их правильно стилизовать. Основное правило звучит так: теневые элементы стилизуются внутри, а обычные элементы – снаружи; однако есть заметные исключения.
========================================================================


========================================================================
Настройка стилей теневого DOM

Теневой DOM может включать в себя стили, такие как <style> или <link rel="stylesheet">.

Локальные стили могут влиять на:

- теневое дерево,
- элемент-хозяин, при помощи псевдоклассов :host и :host(),
- слотовые элементы (из светлого DOM), ::slotted(селектор) позволяет стилизовать сами слотовые элементы, но не их дочерние элементы.

Стили документов могут влиять на:

- элемент-хозяин (так как он находится во внешнем документе)
- слотовые элементы и их содержимое (так как они также физически присутствуют во внешнем документе)

Когда свойства CSS конфликтуют, обычно стили документа имеют приоритет, если только свойство не помечено как !important. Тогда предпочтение отдаётся локальным стилям.

Пользовательские свойства CSS проникают через теневой DOM. Они используются как «хуки» для придания элементам стиля:

1. Компонент использует пользовательское CSS-свойство для стилизации ключевых элементов, например var(--component-name-title, <значение по умолчанию>).
2. Автор компонента публикует эти свойства для разработчиков, они так же важны, как и другие общедоступные методы компонента.
3. Когда разработчик хочет стилизовать заголовок, он назначает CSS-свойство --component-name-title для элемента-хозяина или выше.
4. Profit!
===================


===================
Теневой DOM и события

Только те события пересекают границы теневого DOM, у которых флаг composed установлен в значение true.

У большинства встроенных событий стоит composed: true, это описано в соответствующих спецификациях:

- UI Events https://www.w3.org/TR/uievents.
- Touch Events https://w3c.github.io/touch-events.
- Pointer Events https://www.w3.org/TR/pointerevents.
- …И так далее.

У некоторых встроенных событий всё же стоит composed: false:

- mouseenter, mouseleave (вообще не всплывают),
- load, unload, abort, error,
- select,
- slotchange.

Эти события могут быть пойманы только на элементах, принадлежащих тому же DOM-дереву.

Если мы генерируем своё событие CustomEvent, то должны явно поставить флаг composed: true.

Обратите внимание, что в случае вложенных компонентов теневые DOM могут быть вложены друг в друга. События с флагом composed всплывают через границы всех теневых DOM. Поэтому, если событие предназначено только для ближайшего внешнего компонента-родителя, мы можем инициировать его на элементе-хозяине и установить флаг composed: false. Тогда оно будет уже вне теневого DOM компонента, но не выплывает наружу в «ещё более внешний» DOM.
===================================================================================


===================================================================================
CSS для JavaScript-разработчика
===================================================================================
О чём пойдёт речь

